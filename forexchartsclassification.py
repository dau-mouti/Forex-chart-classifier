# -*- coding: utf-8 -*-
"""ForexChartsclassification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fTPw3mu2Oa68Wv6CZ-rNwWAO76X8eYix

Developing the path
"""

from google.colab import drive
drive.mount('/content/drive')

dataset_path = '/content/drive/MyDrive/charts'

""" Load candlestick chart images from the charts/ folder (with buy/ and sell/ subfolders).

Rescaling and resizing, and preparing them for training a binary image classification model using TensorFlow and Keras.
"""

from tensorflow.keras.preprocessing.image import ImageDataGenerator
#loadin the data
datagen = ImageDataGenerator(
    rescale=1./255,
    validation_split=0.2  # No augmentation
)

# training
train_gen = datagen.flow_from_directory(
    dataset_path,
    target_size=(224, 224),
    batch_size=32,
    class_mode='binary',
    subset='training'
)

#Validation
val_gen = datagen.flow_from_directory(
    dataset_path,
    target_size=(224, 224),
    batch_size=32,
    class_mode='binary',
    subset='validation'
)

"""Build a CNN Architecture"""

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout

# Initialize the model
model = Sequential()

# Convolutional layer 1
model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(224, 224, 3)))
model.add(MaxPooling2D(pool_size=(2, 2)))

# Convolutional layer 2
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

# Convolutional layer 3
model.add(Conv2D(128, (3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

# Flatten and dense layers
model.add(Flatten())
model.add(Dropout(0.5))
model.add(Dense(128, activation='relu'))
model.add(Dense(1, activation='sigmoid'))  # Binary output: buy/sell

"""Compiling the model"""

model.compile(
    optimizer='adam',
    loss='binary_crossentropy',
    metrics=['accuracy']
)

"""Train the CNN Model"""

history = model.fit(
    train_gen,
    validation_data=val_gen,
    epochs=10
)

"""Transfer Learning with ResNet50"""

from tensorflow.keras.applications import ResNet50
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, Flatten, Dropout, GlobalAveragePooling2D
from tensorflow.keras.optimizers import Adam

# Load base model with pretrained weights, exclude the top classifier layer
base_model = ResNet50(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

# Freeze base model layers
for layer in base_model.layers:
    layer.trainable = False

# Add custom classifier head
x = base_model.output
x = GlobalAveragePooling2D()(x)
x = Dense(128, activation='relu')(x)
x = Dropout(0.5)(x)
predictions = Dense(1, activation='sigmoid')(x)

model = Model(inputs=base_model.input, outputs=predictions)

# Compile the model
model.compile(optimizer=Adam(learning_rate=0.0001),
              loss='binary_crossentropy',
              metrics=['accuracy'])

""" Train the Model"""

history = model.fit(
    train_gen,
    validation_data=val_gen,
    epochs=10
)

"""Unfreeze Top Layers for Fine-Tuning"""

# Unfreeze top 50 layers from the actual base_model, not model.layers[0]
for layer in base_model.layers[-50:]:
    layer.trainable = True

"""Then recompiling and continue training:"""

from tensorflow.keras.optimizers import Adam

model.compile(
    optimizer=Adam(learning_rate=1e-5),
    loss='binary_crossentropy',
    metrics=['accuracy']
)

history_finetune = model.fit(
    train_gen,
    validation_data=val_gen,
    epochs=10
)

from tensorflow.keras.callbacks import EarlyStopping

early_stop = EarlyStopping(monitor='val_loss', patience=3, restore_best_weights=True)

history_finetune_2 = model.fit(
    train_gen,
    validation_data=val_gen,
    epochs=10,
    callbacks=[early_stop]
)

"""saving the model."""

model.save('/content/drive/MyDrive/forex_chart_classifier_v1.h5')

"""Getting the validation data."""

from tensorflow.keras.preprocessing.image import ImageDataGenerator

# Recreate the ImageDataGenerator
datagen = ImageDataGenerator(rescale=1./255, validation_split=0.2)

# Update this path if needed
dataset_path = '/content/drive/MyDrive/charts'

# Recreate validation generator
val_gen = datagen.flow_from_directory(
    dataset_path,
    target_size=(224, 224),
    batch_size=32,
    class_mode='binary',
    subset='validation',
    shuffle=False
)

from tensorflow.keras.models import load_model
model = load_model('/content/drive/MyDrive/forex_chart_classifier_v1.h5')

"""Validation. Visualizations."""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report, confusion_matrix, roc_curve, auc
import seaborn as sns

# Reset validation generator and get predictions
val_gen.reset()
pred_probs = model.predict(val_gen, verbose=1)
pred_classes = (pred_probs > 0.5).astype("int32").flatten()

# Get true labels
true_classes = val_gen.classes
class_labels = list(val_gen.class_indices.keys())

# Classification Report
print("Classification Report:")
print(classification_report(true_classes, pred_classes, target_names=class_labels))

# Confusion Matrix
cm = confusion_matrix(true_classes, pred_classes)
plt.figure(figsize=(6, 5))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=class_labels, yticklabels=class_labels)
plt.title('Confusion Matrix')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.show()

# ROC Curve
fpr, tpr, thresholds = roc_curve(true_classes, pred_probs)
roc_auc = auc(fpr, tpr)

plt.figure(figsize=(7, 5))
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (AUC = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC) Curve')
plt.legend(loc="lower right")
plt.show()

"""Install Any Missing Libraries"""

!pip install tensorflow matplotlib

"""Import Libraries and Load the Model"""

from google.colab import files
uploaded = files.upload()

img_path = list(uploaded.keys())[0]
img = image.load_img(img_path, target_size=(224, 224))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0) / 255.0

confidence = model.predict(img_array)[0][0]
label = 'Buy' if confidence >= 0.5 else 'Sell'

print(f"Prediction: {label}")
print(f"Confidence: {confidence*100:.2f}%")

plt.imshow(img)
plt.title(f"{label} ({confidence*100:.2f}%)")
plt.axis('off')
plt.show()

import tensorflow as tf
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image
import numpy as np
import matplotlib.pyplot as plt
import os

model = load_model('/content/drive/MyDrive/forex_chart_classifier_v1.h5')

"""Prediction with Confidence

UI by Gradio
"""

# Step 1: Install Gradio
!pip install -q gradio

# Step 2: Import libraries
import gradio as gr
import numpy as np
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image
from google.colab import drive
drive.mount('/content/drive')

# Step 3: Load  trained model
model = load_model('/content/drive/MyDrive/forex_chart_classifier_v1.h5')

# Step 4: Define class names and prediction function
class_names = ['Buy', 'Sell']  # make sure these match your folder labels

def predict_chart(img):
    img = img.resize((224, 224))  # Resize to model input
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0) / 255.0  # Normalize

    prediction = model.predict(img_array)[0][0]  # Binary classification
    confidence = prediction if prediction > 0.5 else 1 - prediction
    label = "Sell" if prediction > 0.5 else "Buy"

    return f"{label} (Confidence: {confidence*100:.2f}%)"

# Step 5: Launch Gradio app
gr.Interface(
    fn=predict_chart,
    inputs=gr.Image(type="pil"),
    outputs="text",
    title="Forex Chart Prediction",
    description="Upload a candlestick chart image to get a Buy/Sell prediction with confidence."
).launch(share=True)